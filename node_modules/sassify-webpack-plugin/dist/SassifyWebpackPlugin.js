'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require('path');
const pify = require('pify');
const fs = require('fs');
const mkdirp = require('mkdirp');
const ParserFactory_1 = require("./parser/ParserFactory");
class SassifyWebpackPlugin {
    /**
     * Setup Sassify Webpack Plugin
     * @param config
     */
    constructor(config) {
        /**
         * Little helper function for checking if passed parameter is an array
         * @param a
         * @returns {boolean}
         */
        this.isArray = function (a) {
            return (!!a) && (a.constructor === Array);
        };
        this._config = config;
        // Pre-process incoming files
        this._config.files.map(file => {
            return Object.assign(file, {
                mtime: null,
            });
        });
    }
    /**
     * Apply method is called by webpack
     * @param compiler
     */
    apply(compiler) {
        let sourceFiles = null;
        // Listen to the make state of the compiler
        compiler.plugin('make', (compilation, callback) => __awaiter(this, void 0, void 0, function* () {
            sourceFiles = yield (this.getSourceFilesToProcess());
            yield this.processFiles(sourceFiles);
            callback();
        }));
        // When a file is not included in the build we still want to watch it
        compiler.plugin('emit', (compilation, callback) => {
            // No sourceFiles found
            if (sourceFiles.length === 0) {
                this._config.files.forEach((file) => __awaiter(this, void 0, void 0, function* () {
                    if (compilation.fileDependencies.indexOf(file.source) === -1) {
                        // Push file to compilation
                        compilation.fileDependencies.push(file.source);
                        // Read and return compilation asset
                        const fileData = yield pify(fs.readFile)(file.source, "utf8");
                        compilation.assets[file.source] = {
                            source: () => {
                                return fileData;
                            },
                            size: () => {
                                return fileData.length;
                            }
                        };
                    }
                }));
            }
            callback();
        });
    }
    /**
     * Returns files to be processed from JS to SCSS equivalent.
     * @returns {Promise<Array<IFile>>}
     */
    getSourceFilesToProcess() {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            for (let i = 0; i < this._config.files.length; i++) {
                const file = this._config.files[i];
                const mtime = yield this.getFileModificationTime(file);
                if (file.mtime !== mtime) {
                    file.mtime = mtime;
                    files.push(file);
                }
            }
            return files;
        });
    }
    /**
     * Returns the modified time of source file
     * @param file
     * @returns {Promise<string>}
     */
    getFileModificationTime(file) {
        return pify(fs.stat)(path.resolve(file.source))
            .then((statResult) => {
            return statResult.mtime.getTime().toString();
        }).catch((statError) => {
            throw statError;
        });
    }
    /**
     * Returns the extension of a file
     * @param filePath
     * @returns {string}
     */
    getFileExtension(filePath) {
        return filePath.split(/\./g).pop().toUpperCase();
    }
    /**
     * Process files and runs their assigned parser
     * @param files
     * @returns {Promise<void>}
     */
    processFiles(files) {
        return __awaiter(this, void 0, void 0, function* () {
            let parsers = new Array(files.length);
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const fileExtension = this.getFileExtension(file.source);
                if (file.parser) {
                    console.log(`[Sassify] Using custom parser for ${fileExtension}`);
                    if (typeof file.parser === 'function') {
                        parsers[i] = new (file.parser(file));
                    }
                    else if (typeof file.parser.default === 'function') {
                        parsers[i] = new file.parser.default(file);
                    }
                    else {
                        throw new Error('[Sassify] Couldn\'t create the parser.');
                    }
                }
                else {
                    parsers[i] = new ParserFactory_1.default(file).parser;
                }
                yield parsers[i].run();
                parsers = [];
            }
        });
    }
}
module.exports = SassifyWebpackPlugin;
