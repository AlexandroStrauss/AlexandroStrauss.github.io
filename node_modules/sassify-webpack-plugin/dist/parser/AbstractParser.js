"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const babel = require("babel-core");
const template = require('../template');
const { NodeVM, VMScript } = require('vm2');
const mustache = require('mustache');
const pify = require('pify');
const fs = require('fs');
const path = require('path');
const mkdirp = require('mkdirp');
class AbstractParser {
    /**
     * @param file
     */
    constructor(file) {
        // Reference to file object
        this.file = null;
        this.file = file;
    }
    /**
     * Flattens compiled object and prepares the object for the mustache template engine
     * @param obj
     * @returns {IVarMap}
     */
    mapObject(obj) {
        if (!obj) {
            return;
        }
        const varMap = {};
        const recurse = (currentObject, rootKey) => {
            Object.keys(currentObject).forEach((key) => {
                if (typeof currentObject[key] === 'string' || typeof currentObject[key] === 'number') {
                    if (rootKey) {
                        if (!varMap[`${rootKey}`]) {
                            varMap[`${rootKey}`] = [];
                        }
                        varMap[rootKey].push({ keyName: key, keyValue: currentObject[key] });
                    }
                }
                else if (typeof currentObject[key] === 'object' && currentObject[key] !== null) {
                    recurse(currentObject[key], key);
                }
            });
        };
        recurse(obj);
        return varMap;
    }
    /**
     * Transforms the source and then runs it
     * @param source
     * @returns {Object}
     */
    evaluateSource(source) {
        source = this.stripExports(source);
        source = this.transformSource(source);
        return this.runSource(source);
    }
    /**
     * stripExports omitted which is surrounded by a sassify-disable/enable string
     * @param source
     * @returns {string}
     */
    stripExports(source) {
        return source.
            replace(/^\/\/[\s\S]sassify-disable[\s\S]*sassify-enable\s*$/gm, '').
            replace(/\/\*[\s\S]+sassify-disable[\s\S]*sassify-enable[\s\S]*\*\//gm, '');
    }
    /**
     * Transforms the source to ES2015
     * @param source
     * @returns {string}
     */
    transformSource(source) {
        // Transform source to es5
        return babel.transform(source, {
            ast: false,
            presets: ['es2015'],
        }).code;
    }
    /**
     * The source code is evaluated through the VM2 (sandbox) module
     * @param source
     * @returns {Object}
     */
    runSource(source) {
        // Spawn a new vm
        const vm = new NodeVM();
        let vmScript = source;
        let compiledSource = null;
        try {
            vmScript = new VMScript(source);
        }
        catch (error) {
            console.error('Failed to compile script.');
            throw error;
        }
        try {
            compiledSource = vm.run(vmScript);
        }
        catch (error) {
            console.error('Failed to execute script.');
            throw error;
        }
        return compiledSource;
    }
    /**
     * Returns the fileName
     * @param filePath
     * @returns {undefined|string}
     */
    getFileName(filePath) {
        return path.basename(filePath);
    }
    /**
     * Read mustache template file
     * @returns {Promise<any>}
     */
    readTemplate() {
        return __awaiter(this, void 0, void 0, function* () {
            const template = !this.file.template ? AbstractParser.DEFAULT_TEMPLATE : this.file.template;
            return pify(fs.readFile)(template, 'utf-8');
        });
    }
    /**
     * Write mustache template file
     * @param templateData
     * @returns {Promise<any>}
     */
    writeTemplate(templateData) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileToWrite = () => pify(fs.writeFile)(this.file.dest, templateData, 'utf8');
            if (!this.file.disableDirectoryCreation) {
                yield pify(mkdirp)(path.dirname(this.file.dest));
            }
            return fileToWrite();
        });
    }
    /**
     * Creation of mustache template
     * @param jsObject
     * @returns {Promise<void>}
     */
    createTemplate(jsObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = this.mapObject(jsObject);
            if (data) {
                const template = yield this.readTemplate();
                const dataKeys = Object.keys(data);
                let processedTemplate = '';
                dataKeys.forEach((key, index) => {
                    // Replace key with map-name/filename if exists (when doing a export default { ... })
                    if (dataKeys.length === 1) {
                        const keyCopy = key;
                        key = this.file.mapName ? this.file.mapName : this.getFileName(this.file.dest)
                            .split('.')[0].replace(/^_/, '');
                        // Create a new key and content with the new key name, remove the old key from object
                        if (key !== keyCopy && data.hasOwnProperty(keyCopy)) {
                            data[key] = data[keyCopy];
                            delete data[keyCopy];
                        }
                    }
                    processedTemplate += template.replace(/__rootKey__/g, key);
                    // Only add two newlines when we are not at EOF
                    processedTemplate += (index + 1) === dataKeys.length ? "\n" : "\n\n";
                });
                yield this.writeTemplate(mustache.render(processedTemplate, data));
            }
        });
    }
}
// Default template for mustache
AbstractParser.DEFAULT_TEMPLATE = template.SCSS_MAP_UNQUOTED;
exports.default = AbstractParser;
